/**
 * P2P File Transfer - Frontend JavaScript with Idempotency and Double-Click Prevention
 * Idempotency key is generated by backend (similar to CSRF token)
 */

// Get idempotency key from backend (injected via Thymeleaf)
let idempotencyKey = globalThis.IDEMPOTENCY_KEY || '';
const messages = globalThis.MESSAGES || {};

// Upload state management
let isUploading = false;

// Send file form handler
document.getElementById('sendForm')?.addEventListener('submit', async function (e) {
    e.preventDefault();

    // Prevent double-click
    if (isUploading) {
        showStatus(messages.uploadInProgress || 'File is being uploaded, please wait...', 'warning');
        return;
    }

    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];

    if (!file) {
        showStatus(messages.selectFile || 'Please select a file', 'danger');
        return;
    }

    // Disable button and set uploading state
    isUploading = true;
    const submitBtn = this.querySelector('button[type="submit"]');
    const originalBtnContent = submitBtn.innerHTML;
    submitBtn.disabled = true;
    submitBtn.innerHTML = `<span class="spinner-border spinner-border-sm me-2"></span>${messages.uploading || 'Uploading...'}`;

    console.log('Using idempotency key from backend:', idempotencyKey);

    // Prepare form data
    const formData = new FormData();
    formData.append('file', file);

    try {
        const response = await fetch('/api/p2p/upload', {
            method: 'POST',
            headers: {
                'X-Idempotency-Key': idempotencyKey
            },
            body: formData
        });

        const result = await response.json();

        if (response.ok) {
            showStatus(
                `${messages.uploadSuccess || 'âœ… Upload successful!'}<br>
                ${messages.fileId || 'File ID:'} <strong>${result.fileId}</strong><br>
                File: ${result.fileName} (${formatFileSize(result.fileSize)})`,
                'success'
            );

            // Update idempotency key for next upload (backend sends new key)
            if (result.newIdempotencyKey) {
                idempotencyKey = result.newIdempotencyKey;
                globalThis.IDEMPOTENCY_KEY = idempotencyKey;
                console.log('New idempotency key for next upload:', idempotencyKey);
            }

            fileInput.value = ''; // Clear input
        } else if (response.status === 409) {
            // Duplicate request
            showStatus(messages.duplicate || 'âš ï¸ Request is being processed, please wait...', 'warning');
        } else {
            showStatus(`${messages.uploadError || 'âŒ Error:'} ${result.error || 'Upload failed'}`, 'danger');
        }
    } catch (error) {
        console.error('Upload error:', error);
        showStatus(`${messages.connectionError || 'âŒ Connection error:'} ${error.message}`, 'danger');
    } finally {
        // Re-enable button
        isUploading = false;
        submitBtn.disabled = false;
        submitBtn.innerHTML = originalBtnContent;
    }
});

// Receive file form handler (placeholder)
document.getElementById('receiveForm')?.addEventListener('submit', function (e) {
    e.preventDefault();
    const key = document.getElementById('keyInput').value;
    showStatus(`${messages.searching || 'ðŸ” Searching for file with key:'} ${key}...`, 'info');
    // NOTE: File receive logic will be implemented when P2P WebRTC connection is ready
});

// Show status message
function showStatus(message, type = 'info') {
    const statusArea = document.getElementById('statusArea');
    if (!statusArea) return;

    const alertClass = `alert-${type}`;
    statusArea.className = `alert ${alertClass}`;
    statusArea.innerHTML = message;
    statusArea.classList.remove('d-none');

    // Auto-hide after 10 seconds for success/info messages
    if (type === 'success' || type === 'info') {
        setTimeout(() => {
            statusArea.classList.add('d-none');
        }, 10000);
    }
}

// Format file size
function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
}

// Prevent form double-submission on Enter key
document.querySelectorAll('form').forEach(form => {
    form.addEventListener('keydown', function (e) {
        if (e.key === 'Enter' && isUploading) {
            e.preventDefault();
            return false;
        }
    });
});

console.log('P2P File Transfer initialized with backend-generated idempotency protection');
